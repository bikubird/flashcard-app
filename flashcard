<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4F46E5">
    <meta name="description" content="è‹±å˜èªå­¦ç¿’ç”¨ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ã‚¢ãƒ—ãƒª">
    <title>è‹±å˜èªãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIuiLseWNmeiqqeODleODqeODg+OCt+ODpeOCq+ODvOODiSIsCiAgInNob3J0X25hbWUiOiAi6Iux5Y2Z6Kqq5bizIiwKICAic3RhcnRfdXJsIjogIi8iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiNGRkZGRkYiLAogICJ0aGVtZV9jb2xvciI6ICIjNEY0NkU1IiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJyUzRSUzQ3RleHQgeT0nLjllbScgZm9udC1zaXplPSc5MCclM0UlRjAlOUYlOTMlOUElM0MvdGV4dCUzRSUzQy9zdmclM0UiLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXQp9">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®Ÿè£…ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ä½¿ç”¨ï¼‰
        window.storage = {
            get: async (key) => {
                const value = localStorage.getItem(key);
                return value ? { key, value } : null;
            },
            set: async (key, value) => {
                localStorage.setItem(key, value);
                return { key, value };
            }
        };

        function FlashcardApp() {
            const [words, setWords] = useState([]);
            const [inputText, setInputText] = useState('');
            const [isStudying, setIsStudying] = useState(false);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [showAnswer, setShowAnswer] = useState(false);
            const [repeatCount, setRepeatCount] = useState(0);
            const [isTranslating, setIsTranslating] = useState(false);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                loadWords();
            }, []);

            const loadWords = async () => {
                try {
                    const result = await window.storage.get('flashcard-words');
                    if (result && result.value) {
                        const savedWords = JSON.parse(result.value);
                        setWords(savedWords);
                    }
                } catch (error) {
                    console.log('åˆå›èµ·å‹•ã¾ãŸã¯å˜èªæœªç™»éŒ²');
                } finally {
                    setIsLoading(false);
                }
            };

            const saveWords = async (newWords) => {
                try {
                    await window.storage.set('flashcard-words', JSON.stringify(newWords));
                } catch (error) {
                    console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                }
            };

            const ipaToKatakana = (ipa) => {
                let result = ipa
                    .replace(/Ã¦/g, 'ã‚¢').replace(/É‘Ë?/g, 'ã‚¢ãƒ¼').replace(/ÊŒ/g, 'ã‚¢')
                    .replace(/eÉª/g, 'ã‚¨ã‚¤').replace(/aÉª/g, 'ã‚¢ã‚¤').replace(/É”Éª/g, 'ã‚ªã‚¤')
                    .replace(/aÊŠ/g, 'ã‚¢ã‚¦').replace(/oÊŠ/g, 'ã‚ªã‚¦').replace(/ÉªÉ™/g, 'ã‚¤ã‚¢')
                    .replace(/eÉ™/g, 'ã‚¨ã‚¢').replace(/ÊŠÉ™/g, 'ã‚¦ã‚¢').replace(/Éª/g, 'ã‚¤')
                    .replace(/iË/g, 'ã‚¤ãƒ¼').replace(/ÊŠ/g, 'ã‚¦').replace(/uË/g, 'ã‚¦ãƒ¼')
                    .replace(/e/g, 'ã‚¨').replace(/É™/g, 'ã‚¢').replace(/ÉœË/g, 'ã‚¢ãƒ¼')
                    .replace(/É”Ë/g, 'ã‚ªãƒ¼').replace(/É’/g, 'ã‚ª').replace(/p/g, 'ãƒ—')
                    .replace(/b/g, 'ãƒ–').replace(/t/g, 'ãƒˆ').replace(/d/g, 'ãƒ‰')
                    .replace(/k/g, 'ã‚¯').replace(/g/g, 'ã‚°').replace(/tÊƒ/g, 'ãƒ')
                    .replace(/dÊ’/g, 'ã‚¸').replace(/f/g, 'ãƒ•').replace(/v/g, 'ãƒ´')
                    .replace(/Î¸/g, 'ã‚¹').replace(/Ã°/g, 'ã‚º').replace(/s/g, 'ã‚¹')
                    .replace(/z/g, 'ã‚º').replace(/Êƒ/g, 'ã‚·ãƒ¥').replace(/Ê’/g, 'ã‚¸ãƒ¥')
                    .replace(/h/g, 'ãƒ').replace(/m/g, 'ãƒ ').replace(/n/g, 'ãƒ³')
                    .replace(/Å‹/g, 'ãƒ³ã‚°').replace(/l/g, 'ãƒ«').replace(/r/g, 'ãƒ«')
                    .replace(/j/g, 'ãƒ¤').replace(/w/g, 'ãƒ¯').replace(/[ËˆËŒ.\/]/g, '');
                return result;
            };

            const translateToEnglish = async (japanese) => {
                setIsTranslating(true);
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1000,
                            messages: [{
                                role: 'user',
                                content: `æ¬¡ã®æ—¥æœ¬èªã‚’è‹±èªã«ç¿»è¨³ã—ã€ãã®ç™ºéŸ³è¨˜å·(IPA)ã‚‚æä¾›ã—ã¦ãã ã•ã„ã€‚

å›ç­”ã¯å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã®ã¿ã§è¿”ã—ã¦ãã ã•ã„ï¼ˆèª¬æ˜ã‚„å‰ç½®ãã¯ä¸è¦ã§ã™ï¼‰:
{
  "english": "è‹±å˜èª",
  "ipa": "/ç™ºéŸ³è¨˜å·/"
}

æ—¥æœ¬èª: ${japanese}`
                            }]
                        })
                    });

                    const data = await response.json();
                    const text = data.content[0].text.trim();
                    const cleanText = text.replace(/```json|```/g, '').trim();
                    const parsed = JSON.parse(cleanText);
                    const katakana = ipaToKatakana(parsed.ipa);

                    return { japanese, english: parsed.english, ipa: parsed.ipa, katakana };
                } catch (error) {
                    console.error('Translation error:', error);
                    return { japanese, english: 'Error', ipa: '/error/', katakana: 'ã‚¨ãƒ©ãƒ¼' };
                } finally {
                    setIsTranslating(false);
                }
            };

            const addWord = async () => {
                if (inputText.trim()) {
                    const newWord = await translateToEnglish(inputText.trim());
                    const updatedWords = [...words, newWord];
                    setWords(updatedWords);
                    await saveWords(updatedWords);
                    setInputText('');
                }
            };

            const deleteWord = async (index) => {
                const updatedWords = words.filter((_, i) => i !== index);
                setWords(updatedWords);
                await saveWords(updatedWords);
            };

            const clearAllWords = async () => {
                if (window.confirm('ã™ã¹ã¦ã®å˜èªã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                    setWords([]);
                    await saveWords([]);
                }
            };

            const exportWords = () => {
                const dataStr = JSON.stringify(words, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'flashcards.json';
                link.click();
                URL.revokeObjectURL(url);
            };

            const importWords = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const imported = JSON.parse(e.target.result);
                            const updatedWords = [...words, ...imported];
                            setWords(updatedWords);
                            await saveWords(updatedWords);
                            alert(`${imported.length}å€‹ã®å˜èªã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`);
                        } catch (error) {
                            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const startStudying = () => {
                if (words.length > 0) {
                    setIsStudying(true);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setRepeatCount(0);
                }
            };

            const handleCardClick = () => {
                if (!showAnswer) {
                    setShowAnswer(true);
                } else {
                    if (repeatCount === 0) {
                        setRepeatCount(1);
                        setShowAnswer(false);
                    } else {
                        if (currentIndex < words.length - 1) {
                            setCurrentIndex(currentIndex + 1);
                            setShowAnswer(false);
                            setRepeatCount(0);
                        } else {
                            setIsStudying(false);
                            setCurrentIndex(0);
                            setRepeatCount(0);
                        }
                    }
                }
            };

            const speakWord = (text) => {
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    setTimeout(() => {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.lang = 'en-US';
                        utterance.rate = 0.8;
                        utterance.volume = 1.0;
                        speechSynthesis.speak(utterance);
                    }, 100);
                }
            };

            useEffect(() => {
                if (isStudying && !showAnswer && words[currentIndex]) {
                    const timer = setTimeout(() => {
                        speakWord(words[currentIndex].english);
                    }, 300);
                    return () => clearTimeout(timer);
                }
            }, [isStudying, currentIndex, showAnswer]);

            if (isLoading) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                        <div className="text-xl text-indigo-600">èª­ã¿è¾¼ã¿ä¸­...</div>
                    </div>
                );
            }

            if (isStudying) {
                const currentWord = words[currentIndex];
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="max-w-2xl w-full">
                            <div className="text-center mb-4 text-gray-600">
                                {currentIndex + 1} / {words.length} (è¡¨ç¤º: {repeatCount + 1}/2å›ç›®)
                            </div>
                            <div onClick={handleCardClick} className="bg-white rounded-2xl shadow-2xl p-12 cursor-pointer hover:shadow-3xl transition-all min-h-[400px] flex flex-col items-center justify-center">
                                {!showAnswer ? (
                                    <>
                                        <div className="text-5xl font-bold text-indigo-600 mb-4">{currentWord.english}</div>
                                        <div className="text-xl text-gray-600 mb-2 font-mono">{currentWord.ipa}</div>
                                        <div className="text-2xl text-gray-500 mb-8">{currentWord.katakana}</div>
                                        <button onClick={(e) => { e.stopPropagation(); speakWord(currentWord.english); }} className="p-4 bg-indigo-100 rounded-full hover:bg-indigo-200 transition-colors">
                                            ğŸ”Š
                                        </button>
                                        <div className="mt-8 text-gray-400">ã‚¿ãƒƒãƒ—ã—ã¦ç­”ãˆã‚’è¡¨ç¤º</div>
                                    </>
                                ) : (
                                    <>
                                        <div className="text-3xl text-gray-400 mb-2">{currentWord.english}</div>
                                        <div className="text-lg text-gray-400 mb-4 font-mono">{currentWord.ipa}</div>
                                        <div className="text-5xl font-bold text-green-600">{currentWord.japanese}</div>
                                        <div className="mt-8 text-gray-400">ã‚¿ãƒƒãƒ—ã—ã¦{repeatCount === 0 ? '2å›ç›®ã¸' : 'æ¬¡ã¸'}</div>
                                    </>
                                )}
                            </div>
                            <button onClick={() => { speechSynthesis.cancel(); setIsStudying(false); setCurrentIndex(0); setRepeatCount(0); }} className="mt-6 w-full py-3 bg-gray-200 rounded-lg hover:bg-gray-300 transition-colors">
                                å­¦ç¿’ã‚’çµ‚äº†
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 sm:p-6">
                    <div className="max-w-4xl mx-auto">
                        <h1 className="text-3xl sm:text-4xl font-bold text-indigo-900 mb-6 sm:mb-8 text-center">ğŸ“š è‹±å˜èªãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰</h1>
                        
                        <div className="bg-white rounded-xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                            <div className="flex flex-col sm:flex-row gap-3">
                                <input type="text" value={inputText} onChange={(e) => setInputText(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && addWord()} placeholder="æ—¥æœ¬èªã‚’å…¥åŠ›ï¼ˆä¾‹: ã‚Šã‚“ã”ï¼‰" className="flex-1 px-4 py-3 border-2 border-indigo-200 rounded-lg focus:border-indigo-500 focus:outline-none text-base" disabled={isTranslating} />
                                <button onClick={addWord} disabled={isTranslating} className="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-400">
                                    {isTranslating ? 'ç¿»è¨³ä¸­...' : 'â• è¿½åŠ '}
                                </button>
                            </div>
                        </div>

                        {words.length > 0 && (
                            <>
                                <button onClick={startStudying} className="w-full mb-4 sm:mb-6 py-4 bg-green-600 text-white rounded-xl text-lg sm:text-xl font-bold hover:bg-green-700 transition-colors">
                                    ğŸ“– å­¦ç¿’ã‚¹ã‚¿ãƒ¼ãƒˆ ({words.length}å˜èª)
                                </button>

                                <div className="flex flex-wrap gap-2 mb-4 sm:mb-6">
                                    <button onClick={exportWords} className="flex-1 min-w-[140px] py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm">
                                        ğŸ’¾ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                                    </button>
                                    <label className="flex-1 min-w-[140px] py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors flex items-center justify-center cursor-pointer text-sm">
                                        ğŸ“¤ ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                                        <input type="file" accept=".json" onChange={importWords} className="hidden" />
                                    </label>
                                    <button onClick={clearAllWords} className="flex-1 min-w-[140px] py-2 px-4 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm">
                                        ğŸ—‘ï¸ å…¨å‰Šé™¤
                                    </button>
                                </div>

                                <div className="bg-white rounded-xl shadow-lg p-4 sm:p-6">
                                    <h2 className="text-lg sm:text-xl font-bold text-gray-800 mb-4">ç™»éŒ²æ¸ˆã¿å˜èª</h2>
                                    <div className="space-y-3">
                                        {words.map((word, index) => (
                                            <div key={index} className="flex items-center justify-between p-3 sm:p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors">
                                                <div className="flex-1 min-w-0 mr-3">
                                                    <div className="font-bold text-indigo-600 text-base sm:text-lg truncate">{word.english}</div>
                                                    <div className="text-xs sm:text-sm text-gray-600 font-mono">{word.ipa}</div>
                                                    <div className="text-xs sm:text-sm text-gray-500">{word.katakana}</div>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <div className="text-sm sm:text-lg text-gray-700">{word.japanese}</div>
                                                    <button onClick={() => deleteWord(index)} className="p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors">
                                                        ğŸ—‘ï¸
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </>
                        )}

                        {words.length === 0 && (
                            <div className="text-center text-gray-500 mt-12">
                                <div className="text-6xl mb-4">ğŸ“š</div>
                                <p>ã¾ã å˜èªãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>
                                <p className="text-sm mt-2">æ—¥æœ¬èªã‚’å…¥åŠ›ã—ã¦å˜èªã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ï¼</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FlashcardApp />, document.getElementById('root'));
    </script>
</body>
</html>
